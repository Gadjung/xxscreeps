import type { Shard } from 'xxscreeps/engine/model/shard';
import type { Subscription } from 'xxscreeps/storage/channel';
import * as Fn from 'xxscreeps/utility/functional';
import * as User from 'xxscreeps/engine/metadata/user';
import { createSandbox, Sandbox } from 'xxscreeps/driver/sandbox';
import { saveRunnerIntentsBlobForRoom } from 'xxscreeps/engine/model/processor';
import { getConsoleChannel, loadUserFlagBlob, loadUserMemoryBlob, saveUserFlagBlobForNextTick, saveVisualsBlob } from 'xxscreeps/engine/model/user';
import { exchange } from 'xxscreeps/utility/utility';
import { getRunnerUserChannel, RunnerIntent, RunnerUserMessage } from './channel';

export class PlayerInstance {
	private branch: string | null;
	private readonly consoleChannel: ReturnType<typeof getConsoleChannel>;
	public consoleEval?: string[];
	public intents?: RunnerIntent[];
	private sandbox?: Sandbox;
	private stale = false;
	private readonly userId: string;
	public roomsVisible: Set<string>;

	constructor(
		private readonly shard: Shard,
		user: User.User,
		private readonly channel: Subscription<RunnerUserMessage>,
	) {
		this.branch = user.code.branch;
		this.roomsVisible = user.roomsVisible;
		this.userId = user.id;
		this.consoleChannel = getConsoleChannel(this.shard, this.userId);

		// Listen for various messages probably sent from backend
		channel.listen(message => {
			switch (message.type) {
				case 'code':
					this.branch = message.id;
					this.stale = true;
					break;

				case 'eval':
					(this.consoleEval ??= []).push(message.expr);
					break;

				case 'intent': {
					(this.intents ??= []).push(message.intent);
					break;
				}

				default:
			}
		});
	}

	static async create(shard: Shard, userId: string) {
		// Connect to channel, load initial user data
		const [ channel, userBlob ] = await Promise.all([
			getRunnerUserChannel(shard, userId).subscribe(),
			shard.storage.blob.get(`user/${userId}/info`),
		]);
		const user = User.read(userBlob);
		return new PlayerInstance(shard, user, channel);
	}

	disconnect() {
		this.channel.disconnect();
		this.sandbox?.dispose();
	}

	async run(this: PlayerInstance, time: number, roomBlobs: Readonly<Uint8Array>[]) {
		// Dispose the current sandbox if the user has pushed new code
		if (this.stale) {
			this.sandbox!.dispose();
			this.sandbox = undefined;
			this.stale = false;
		}

		// If there's no sandbox load the required data and initialize
		if (!this.sandbox) {
			const [ codeBlob, flagBlob, memoryBlob ] = await Promise.all([
				this.shard.storage.blob.get(`user/${this.userId}/${this.branch}`),
				loadUserFlagBlob(this.shard, this.userId),
				loadUserMemoryBlob(this.shard, this.userId),
			]);
			this.sandbox = await createSandbox({
				userId: this.userId,
				codeBlob, flagBlob, memoryBlob,
				terrainBlob: this.shard.terrainBlob,
				writeConsole: (fd, payload) => {
					const type = ([ 'result', 'log', 'error' ] as const)[fd];
					this.consoleChannel.publish({ type, value: payload }).catch(console.error);
				},
			});
		}

		// Run the tick
		const result = await (async() => {
			try {
				return await this.sandbox!.run({
					time,
					roomBlobs,
					consoleEval: exchange(this, 'consoleEval'),
					userIntents: exchange(this, 'intents'),
				});
			} catch (err) {
				console.error(err.stack);
				return { flagBlob: undefined, intentBlobs: {}, visualsBlob: undefined, memory: undefined };
			}
		})();

		// Save runtime results
		const [ savedRoomNames ] = await Promise.all([
			// Save intent blobs
			Fn.map(Object.entries(result.intentBlobs), async([ roomName, intents ]) => {
				if (this.roomsVisible.has(roomName)) {
					await saveRunnerIntentsBlobForRoom(this.shard, roomName, this.userId, intents);
					return roomName;
				} else {
					console.error(`Runtime sent intent for non-visible room. User: ${this.userId}; Room: ${roomName}; Tick: ${time}`);
				}
			}),

			// Save flags
			// TODO: Maybe some kind of sanity check on the blob since it was generated by a
			// runner?
			result.flagBlob && saveUserFlagBlobForNextTick(this.shard, this.userId, result.flagBlob),

			saveVisualsBlob(this.shard, this.userId, time, result.visualsBlob),

			// Save memory
			result.memory && this.shard.storage.blob.set(`memory/${this.userId}`, result.memory),
		]);

		// Return affected room
		return [ ...Fn.filter(await Promise.all(savedRoomNames)) ];
	}
}
