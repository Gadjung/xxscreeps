import type { Shard } from 'xxscreeps/engine/model/shard';
import type { World } from 'xxscreeps/game/map';
import type { Subscription } from 'xxscreeps/storage/channel';
import * as Fn from 'xxscreeps/utility/functional';
import * as User from 'xxscreeps/engine/metadata/user';
import { createSandbox, Sandbox } from 'xxscreeps/driver/sandbox';
import { publishRunnerIntentsForRoom } from 'xxscreeps/engine/model/processor';
import { loadUserFlagBlob, saveUserFlagBlobForNextTick } from 'xxscreeps/mods/flag/model';
import { getConsoleChannel, loadUserMemoryBlob, saveVisualsBlob } from 'xxscreeps/engine/model/user';
import { exchange } from 'xxscreeps/utility/utility';
import { getRunnerUserChannel, RunnerIntent, RunnerUserMessage } from './channel';

export class PlayerInstance {
	private branch: string | null;
	private readonly consoleChannel: ReturnType<typeof getConsoleChannel>;
	public consoleEval?: string[];
	public intents?: RunnerIntent[];
	private sandbox?: Sandbox;
	private stale = false;
	public readonly userId: string;

	constructor(
		public readonly shard: Shard,
		private readonly world: World,
		user: User.User,
		private readonly channel: Subscription<RunnerUserMessage>,
	) {
		this.branch = user.code.branch;
		this.userId = user.id;
		this.consoleChannel = getConsoleChannel(this.shard, this.userId);

		// Listen for various messages probably sent from backend
		channel.listen(message => {
			switch (message.type) {
				case 'code':
					this.branch = message.id;
					this.stale = true;
					break;

				case 'eval':
					(this.consoleEval ??= []).push(message.expr);
					break;

				case 'intent': {
					(this.intents ??= []).push(message.intent);
					break;
				}

				default:
			}
		});
	}

	static async create(shard: Shard, world: World, userId: string) {
		// Connect to channel, load initial user data
		const [ channel, userBlob ] = await Promise.all([
			getRunnerUserChannel(shard, userId).subscribe(),
			shard.blob.reqBuffer(`user/${userId}/info`),
		]);
		const user = User.read(userBlob);
		return new PlayerInstance(shard, world, user, channel);
	}

	disconnect() {
		this.channel.disconnect();
		this.sandbox?.dispose();
	}

	async run(this: PlayerInstance, time: number, roomBlobs: Readonly<Uint8Array>[], roomNames: string[]) {
		// Dispose the current sandbox if the user has pushed new code
		if (this.stale) {
			this.sandbox!.dispose();
			this.sandbox = undefined;
			this.stale = false;
		}

		// If there's no sandbox load the required data and initialize
		if (!this.sandbox) {
			const [ codeBlob, flagBlob, memoryBlob ] = await Promise.all([
				this.shard.blob.reqBuffer(`user/${this.userId}/${this.branch}`),
				loadUserFlagBlob(this.shard, this.userId),
				loadUserMemoryBlob(this.shard, this.userId),
			]);
			this.sandbox = await createSandbox({
				userId: this.userId,
				codeBlob, flagBlob, memoryBlob,
				shardName: this.shard.name,
				terrainBlob: this.world.terrainBlob,
			}, (fd, payload) => {
				const type = ([ 'result', 'log', 'error' ] as const)[fd];
				this.consoleChannel.publish({ type, value: payload }).catch(console.error);
			});
		}

		// Run the tick
		const result = await (async() => {
			try {
				return await this.sandbox!.run({
					time,
					roomBlobs,
					consoleEval: exchange(this, 'consoleEval'),
					backendIntents: exchange(this, 'intents'),
				});
			} catch (err) {
				console.error(err.stack);
			}
		})();

		// Save runtime results
		if (result) {
			await Promise.all([
				// Publish intent blobs
				Promise.all(Fn.map(roomNames, roomName =>
					publishRunnerIntentsForRoom(this.shard, this.userId, roomName, time, result.intentPayloads[roomName]))),

				// Save flags
				// TODO: Maybe some kind of sanity check on the blob since it was generated by a
				// runner?
				result.flagNextBlob && saveUserFlagBlobForNextTick(this.shard, this.userId, result.flagNextBlob),

				// Save visuals
				// saveVisualsBlob(this.shard, this.userId, time, result.visualsBlob),

				// Save memory
				result.memoryNextBlob && this.shard.blob.set(`memory/${this.userId}`, result.memoryNextBlob),
			]);
		} else {
			// Publish empty results to move processing along
			await Promise.all(Fn.map(roomNames, roomName => publishRunnerIntentsForRoom(this.shard, this.userId, roomName, time)));
		}
	}
}
